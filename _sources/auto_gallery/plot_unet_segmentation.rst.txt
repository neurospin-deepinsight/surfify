
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_gallery/plot_unet_segmentation.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_gallery_plot_unet_segmentation.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_gallery_plot_unet_segmentation.py:


UNet segmentation
=================

Credit: A Grigis

A simple example on how to use the SphericalUNet architecture on the
classification dataset.

.. GENERATED FROM PYTHON SOURCE LINES 11-22

.. code-block:: Python


    import numpy as np
    import matplotlib.pyplot as plt
    import torch
    from torch import nn
    from torch.utils.data import DataLoader
    from surfify import utils
    from surfify import plotting
    from surfify import models
    from surfify import datasets








.. GENERATED FROM PYTHON SOURCE LINES 23-28

Inspect dataset
---------------

First we load the classification dataset (with 3 classes) and inspect the
genrated labels.

.. GENERATED FROM PYTHON SOURCE LINES 28-42

.. code-block:: Python


    standard_ico = True
    ico_order = 3
    n_classes = 3
    n_epochs = 20
    ico_vertices, ico_triangles = utils.icosahedron(
        order=ico_order, standard_ico=standard_ico)
    n_vertices = len(ico_vertices)
    X, y = datasets.make_classification(
        ico_vertices, n_samples=40, n_classes=n_classes, scale=1, seed=42)
    print("Surface:", ico_vertices.shape, ico_triangles.shape)
    print("Data:", X.shape, y.shape)
    plotting.plot_trisurf(ico_vertices, ico_triangles, y, is_label=True)




.. image-sg:: /auto_gallery/images/sphx_glr_plot_unet_segmentation_001.png
   :alt: plot unet segmentation
   :srcset: /auto_gallery/images/sphx_glr_plot_unet_segmentation_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Surface: (642, 3) (1280, 3)
    Data: (40, 3, 642) (642,)




.. GENERATED FROM PYTHON SOURCE LINES 43-49

Train the model
---------------

We now train the SphericalUNet model using a CrossEntropy loss and a SGD
optimizer. As it is obvious to segment the input classification dataset
an accuracy of 100% is expected.

.. GENERATED FROM PYTHON SOURCE LINES 49-91

.. code-block:: Python


    dataset = datasets.ClassificationDataset(
        ico_vertices, n_samples=40, n_classes=n_classes, scale=1, seed=42)
    loader = DataLoader(dataset, batch_size=5, shuffle=True)
    model = models.SphericalUNet(
        in_order=ico_order, in_channels=n_classes, out_channels=n_classes,
        depth=2, start_filts=8, conv_mode="DiNe", dine_size=1, up_mode="transpose",
        standard_ico=standard_ico)
    loss_fn = nn.CrossEntropyLoss()
    optimizer = torch.optim.SGD(
        model.parameters(), lr=0.1, momentum=0.99, weight_decay=1e-4)
    size = len(loader.dataset)
    n_batches = len(loader)
    for epoch in range(n_epochs):
        for batch, (X, y) in enumerate(loader):
            pred = model(X)
            loss = loss_fn(pred, y)
            optimizer.zero_grad()
            loss.backward()
            optimizer.step()
            loss, current = loss.item(), batch * len(X)
            if epoch % 5 == 0:
                print("loss {0}: {1:>7f}  [{2:>5d}/{3:>5d}]".format(
                    epoch, loss, current, size))
    model.eval()
    test_loss, correct = 0, 0
    y_preds = []
    with torch.no_grad():
        for X, y in loader:
            pred = model(X)
            test_loss += loss_fn(pred, y).item()
            logit = torch.nn.functional.softmax(pred, dim=1)
            y_pred = pred.argmax(dim=1)
            correct += (y_pred == y).type(torch.float).sum().item()
            y_preds.append(y_pred.numpy())
    test_loss /= n_batches
    correct /= (size * n_vertices)
    y_preds = np.concatenate(y_preds, axis=0)
    print("Test Error: \n Accuracy: {0:>0.1f}%, Avg loss: {1:>8f}".format(
        100 * correct, test_loss))






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    loss 0: 1.219455  [    0/   40]
    loss 0: 0.893271  [    5/   40]
    loss 0: 0.728664  [   10/   40]
    loss 0: 0.565189  [   15/   40]
    loss 0: 0.467813  [   20/   40]
    loss 0: 0.378665  [   25/   40]
    loss 0: 0.295605  [   30/   40]
    loss 0: 0.223579  [   35/   40]
    loss 5: 0.003504  [    0/   40]
    loss 5: 0.003411  [    5/   40]
    loss 5: 0.003212  [   10/   40]
    loss 5: 0.002970  [   15/   40]
    loss 5: 0.002711  [   20/   40]
    loss 5: 0.002424  [   25/   40]
    loss 5: 0.002084  [   30/   40]
    loss 5: 0.001708  [   35/   40]
    loss 10: 0.000110  [    0/   40]
    loss 10: 0.000096  [    5/   40]
    loss 10: 0.000085  [   10/   40]
    loss 10: 0.000075  [   15/   40]
    loss 10: 0.000066  [   20/   40]
    loss 10: 0.000059  [   25/   40]
    loss 10: 0.000052  [   30/   40]
    loss 10: 0.000046  [   35/   40]
    loss 15: 0.000001  [    0/   40]
    loss 15: 0.000001  [    5/   40]
    loss 15: 0.000001  [   10/   40]
    loss 15: 0.000001  [   15/   40]
    loss 15: 0.000001  [   20/   40]
    loss 15: 0.000001  [   25/   40]
    loss 15: 0.000000  [   30/   40]
    loss 15: 0.000000  [   35/   40]
    Test Error: 
     Accuracy: 100.0%, Avg loss: 0.000004




.. GENERATED FROM PYTHON SOURCE LINES 92-97

Inspect the predicted labels
----------------------------

Finally the predicted labels of the first sample are displayed. As expected
they corresspond exactly to the ground truth.

.. GENERATED FROM PYTHON SOURCE LINES 97-100

.. code-block:: Python


    plotting.plot_trisurf(ico_vertices, ico_triangles, y_preds[0], is_label=True)
    plt.show()



.. image-sg:: /auto_gallery/images/sphx_glr_plot_unet_segmentation_002.png
   :alt: plot unet segmentation
   :srcset: /auto_gallery/images/sphx_glr_plot_unet_segmentation_002.png
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 5.389 seconds)

**Estimated memory usage:**  296 MB


.. _sphx_glr_download_auto_gallery_plot_unet_segmentation.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_unet_segmentation.ipynb <plot_unet_segmentation.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_unet_segmentation.py <plot_unet_segmentation.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_unet_segmentation.zip <plot_unet_segmentation.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
