
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_gallery/plot_match_icosahedron.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_gallery_plot_match_icosahedron.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_gallery_plot_match_icosahedron.py:


Icosahedron matching
====================

Credit: C Ambroise

A simple example on how to match two icosahedrons of the same order.

.. GENERATED FROM PYTHON SOURCE LINES 10-20

.. code-block:: Python

    import os
    import math
    import warnings
    import numpy as np
    from scipy.spatial import transform
    import matplotlib.pyplot as plt
    from mpl_toolkits.mplot3d import axes3d
    from surfify.plotting import plot_trisurf
    from surfify.utils import icosahedron, ico2ico








.. GENERATED FROM PYTHON SOURCE LINES 21-22

We first build the reference icosahedron.

.. GENERATED FROM PYTHON SOURCE LINES 22-27

.. code-block:: Python


    order = 3
    vertices_norm, triangles_norm = icosahedron(order, standard_ico=True)
    print(vertices_norm.shape, triangles_norm.shape)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    (642, 3) (1280, 3)




.. GENERATED FROM PYTHON SOURCE LINES 28-29

Then we fetch freesurfer's icosahedron of the same order.

.. GENERATED FROM PYTHON SOURCE LINES 29-33

.. code-block:: Python


    vertices, triangles = icosahedron(order)
    print(vertices.shape, triangles.shape)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    (642, 3) (1280, 3)




.. GENERATED FROM PYTHON SOURCE LINES 34-36

We try to find the optimal rotation between the two icosahedrons using
the scipy module.

.. GENERATED FROM PYTHON SOURCE LINES 36-40

.. code-block:: Python


    rotation, rmse = transform.Rotation.align_vectors(vertices_norm, vertices)
    print(rmse)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    29.54571598073452




.. GENERATED FROM PYTHON SOURCE LINES 41-48

Okay, does not seem to be working, because the rmse is supposed to be very
close or equal to zero

We print the vertices to try to find the issue here: it seems that the order
of the vertices is not the same in the two matrices. That is why the previous
algorithm did not work properly, since it can only match to the corresponding
row in the other matrix.

.. GENERATED FROM PYTHON SOURCE LINES 48-52

.. code-block:: Python


    print(vertices_norm)
    print(vertices)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [[-0.52573111  0.85065081  0.        ]
     [ 0.52573111  0.85065081  0.        ]
     [-0.52573111 -0.85065081  0.        ]
     ...
     [ 0.96386126  0.2664047   0.        ]
     [ 0.91298249  0.39960705 -0.08232358]
     [ 0.91298249  0.39960705  0.08232358]]
    [[ 0.      0.      1.    ]
     [ 0.8944  0.      0.4472]
     [ 0.2764  0.8507  0.4472]
     ...
     [ 0.1815  0.296  -0.9378]
     [ 0.0272  0.3462 -0.9378]
     [ 0.0692  0.213  -0.9746]]




.. GENERATED FROM PYTHON SOURCE LINES 53-55

Here we plot the sufaces together to show that they have the same structure
but their vertices are not at the same places.

.. GENERATED FROM PYTHON SOURCE LINES 55-63

.. code-block:: Python


    fig, ax = plt.subplots(1, 1, subplot_kw={
            "projection": "3d", "aspect": "auto"}, figsize=(10, 10))
    plot_trisurf(vertices_norm, triangles_norm, fig=fig, ax=ax, alpha=0.3,
                 edgecolors="blue")
    plot_trisurf(vertices, triangles, fig=fig, ax=ax, alpha=0.3,
                 edgecolors="green")




.. image-sg:: /auto_gallery/images/sphx_glr_plot_match_icosahedron_001.png
   :alt: plot match icosahedron
   :srcset: /auto_gallery/images/sphx_glr_plot_match_icosahedron_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 64-69

To compute the rotation between the two structures, we do not need all the
vertices. So we consider a small subset of 4 points that have correspondances
in both icosahedrons (for instance they have the same absolute
values, only sign differs, for each dimension).
The 4 firsts work for the reference icosahedron.

.. GENERATED FROM PYTHON SOURCE LINES 69-72

.. code-block:: Python


    vertices_of_interest_norm = vertices_norm[:4]








.. GENERATED FROM PYTHON SOURCE LINES 73-74

Now we search for 4 similar vertices in the FreeSurfer icosahedron.

.. GENERATED FROM PYTHON SOURCE LINES 74-84

.. code-block:: Python


    for i in range(len(vertices)):
        coords_of_interest = vertices[i]
        idx_of_interest = (np.abs(vertices) == np.abs(coords_of_interest)).all(1)
        if idx_of_interest.sum() == 4:
            vertices_of_interest = vertices[idx_of_interest]
            fs_row_idx = i
            break
    print(fs_row_idx)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    2




.. GENERATED FROM PYTHON SOURCE LINES 85-89

Now we need to find a rotation between these two set of points.
Many can be possible, depending on the ordering of the points. To do this,
we compute the optimal rotation matrix between our reference points and
the others variously permuted, until we find a rotation that works.

.. GENERATED FROM PYTHON SOURCE LINES 89-110

.. code-block:: Python


    import itertools
    permutations = itertools.permutations(range(4))
    n_permutations = math.factorial(4)
    it = 0
    best_rmse = rmse
    best_rotation = rotation
    while rmse > 0 and it < n_permutations:
        it += 1
        order = np.array(next(permutations))
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", category=UserWarning)
            rotation, rmse = transform.Rotation.align_vectors(
                    vertices_of_interest_norm, vertices_of_interest[order])
        if rmse < best_rmse:
            best_rmse = rmse
            best_rotation = rotation
    print("Number of permutations tested {}/{}".format(it, math.factorial(4)))
    print(best_rotation.as_matrix())
    print(best_rmse)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Number of permutations tested 24/24
    [[-0.52575203  0.         -0.85063788]
     [ 0.          1.          0.        ]
     [ 0.85063788  0.         -0.52575203]]
    9.971395685383565e-05




.. GENERATED FROM PYTHON SOURCE LINES 111-113

Now we found a rotation that works, we can simply apply it to the icosahedron
so it matches the reference one.

.. GENERATED FROM PYTHON SOURCE LINES 113-121

.. code-block:: Python


    fig, ax = plt.subplots(1, 1, subplot_kw={
            "projection": "3d", "aspect": "auto"}, figsize=(10, 10))
    plot_trisurf(vertices_norm, triangles_norm, fig=fig, ax=ax, alpha=0.3,
                 edgecolors="blue")
    plot_trisurf(best_rotation.apply(vertices), triangles, fig=fig, ax=ax,
                 alpha=0.3, edgecolors="green")




.. image-sg:: /auto_gallery/images/sphx_glr_plot_match_icosahedron_002.png
   :alt: plot match icosahedron
   :srcset: /auto_gallery/images/sphx_glr_plot_match_icosahedron_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 122-127

To easily solve the issue outlined in this example, you can find a
function in the `surfify.utils` module. `ico2ico` allows you to find a
proper rotation between a reference icosahedron and another one.
We plot only half of the triangles of each icosahedron so it clearly appears
that they are the same.

.. GENERATED FROM PYTHON SOURCE LINES 127-135

.. code-block:: Python

    rotation = ico2ico(vertices, vertices_norm)
    fig, ax = plt.subplots(1, 1, subplot_kw={
            "projection": "3d", "aspect": "auto"}, figsize=(10, 10))
    plot_trisurf(vertices_norm, triangles_norm[::2], fig=fig, ax=ax, alpha=0.3,
                 edgecolors="blue")
    plot_trisurf(rotation.apply(vertices), triangles[::2], fig=fig, ax=ax,
                 alpha=0.3, edgecolors="green")
    plt.show()



.. image-sg:: /auto_gallery/images/sphx_glr_plot_match_icosahedron_003.png
   :alt: plot match icosahedron
   :srcset: /auto_gallery/images/sphx_glr_plot_match_icosahedron_003.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    /opt/hostedtoolcache/Python/3.12.9/x64/lib/python3.12/site-packages/surfify/utils/coord.py:246: UserWarning: A proper mapping between the two icosahedrons could not be found. The closest rotation has a rmse of 0.9190925817849288.
      warnings.warn(





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 2.607 seconds)

**Estimated memory usage:**  80 MB


.. _sphx_glr_download_auto_gallery_plot_match_icosahedron.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_match_icosahedron.ipynb <plot_match_icosahedron.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_match_icosahedron.py <plot_match_icosahedron.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_match_icosahedron.zip <plot_match_icosahedron.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
