<!doctype html>
<html lang="en">

    <head>

		<!-- Required meta tags -->
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

        <title>surfify</title>
        
        <!-- CSS -->
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,500&display=swap">
		<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
        <link rel="stylesheet" href="../../../_static/css/jquery.mCustomScrollbar.min.css">
        <link rel="stylesheet" href="../../../_static/css/animate.css">
        <link rel="stylesheet" href="../../../_static/css/style.css">
        <link rel="stylesheet" href="../../../_static/css/jquery.mosaic.css">
        <link rel="stylesheet" href="../../../_static/sg_gallery.css">
        <link rel="stylesheet" href="../../../_static/css/media-queries.css">
        <link rel="stylesheet" href="../../../_static/css/pygment.css">

        <!-- Favicon and touch icons -->
        <link rel="shortcut icon" href="../../../_static/ico/favicon.png">
        <link rel="apple-touch-icon-precomposed" sizes="144x144" href="../../../_static/ico/apple-touch-icon-144-precomposed.png">
        <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../../../_static/ico/apple-touch-icon-114-precomposed.png">
        <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../../../_static/ico/apple-touch-icon-72-precomposed.png">
        <link rel="apple-touch-icon-precomposed" href="../../../_static/ico/apple-touch-icon-57-precomposed.png">

    </head>

    <body>

		<!-- Wrapper -->
    	<div class="wrapper">

			<!-- Sidebar -->
			<nav class="sidebar">
				
				<!-- close sidebar menu -->
				<div class="dismiss">
					<i class="fas fa-arrow-left"></i>
				</div>
				
				<div class="logo"">
					<h3><a href="../../../index.html">Sidebar Menu</a></h3>
				</div>

                <!-- info setup -->
                    <p class="doc-version">
                        This documentation is for surfify <strong>version 0.3.0</strong>
                    </p>
                <p class="citing">
                    If you use the software, please do not hesitate to 
                    <a &mdash; <a href="https://github.com/neurospin-deepinsight/surfify">
                    Report a Bug</a>.
                </p>
				
                <!-- links -->
                
                
				<ul class="list-unstyled menu-elements">
					<li class="active">
						<a href="../../../index.html"><i class="fas fa-home"></i> Home</a>
					</li>
					<li>
						<a href="../../../generated/installation.html"><i class="fas fa-cog"></i> Installation</a>
					</li>
					<li>
						<a href="../../../auto_gallery/index.html"><i class="fas fa-eye"></i> Gallery</a>
					</li>
					<li>
						<a href="../../../generated/documentation.html"><i class="fas fa-pencil-alt"></i> API documentation</a>
					</li>
					<li>
						<a href="../../../generated/search.html"><i class="fas fa-search"></i> Search</a>
					</li>
					<li>
						<a href="https://joliot.cea.fr/drf/joliot/Pages/Entites_de_recherche/NeuroSpin.aspx"><i class="fas fa-external-link-alt"></i> NeuroSpin webPage</a>
					</li>
					<li>
						<a href="#otherSections" data-toggle="collapse" aria-expanded="false" class="dropdown-toggle" role="button" aria-controls="otherSections">
							<i class="fas fa-sync"></i>Sections Shortcuts
						</a>
						<ul class="collapse list-unstyled" id="otherSections">
                            <li>LINKS</li><li><a href='https://github.com/neurospin-deepinsight/deepinsight'>deepinsight</a></li>
                            
                            <li>API</li>
                            <li><a href="../../../generated/surfify.html">surfify</a></li><li><a href="../../../generated/surfify.augmentation.html">surfify.augmentation</a></li><li><a href="../../../generated/surfify.datasets.html">surfify.datasets</a></li><li><a href="../../../generated/surfify.losses.html">surfify.losses</a></li><li><a href="../../../generated/surfify.models.html">surfify.models</a></li><li><a href="../../../generated/surfify.nn.html">surfify.nn</a></li><li><a href="../../../generated/surfify.plotting.html">surfify.plotting</a></li><li><a href="../../../generated/surfify.utils.html">surfify.utils</a></li>
						</ul>
					</li>
				</ul>
				
                <!-- go top page -->
				<div class="to-top">
					<a class="btn btn-primary btn-customized-3" href="#" role="button">
	                    <i class="fas fa-arrow-up"></i> Top
	                </a>
				</div>
			
                <!-- change color -->
				<div class="dark-light-buttons">
					<a class="btn btn-primary btn-customized-4 btn-customized-dark" href="#" role="button">Dark</a>
					<a class="btn btn-primary btn-customized-4 btn-customized-light" href="#" role="button">Light</a>
				</div>
			
			</nav>
			<!-- End sidebar -->
			
			<!-- Dark overlay -->
    		<div class="overlay"></div>

			<!-- Content -->
			<div class="content">
			
				<!-- open sidebar menu -->
				<a class="btn btn-primary btn-customized open-menu" href="#" role="button">
                    <i class="fas fa-align-left"></i> <span>Menu</span>
                </a>

		        <!-- Top content -->
		        <div class="top-content section-container" id="top-content">
			        <div class="container">
			            <div class="row">
                            <div class="col-md-3 section-5-box banner-logo">
                                <img alt="Logo" src="../../../_static/surfify.png">
                            </div>
			                <div class="col-md-7 section-5-box">
			                	<h1 class="wow fadeIn">    <p>PyTorch toolbox to work with spherical surfaces.</p></h1>
			                </div>
			            </div>
			        </div>
		        </div>
                    
                    <div class="document">
                        <h1>Source code for surfify.utils.sampling</h1><div class='divider-1 wow fadeInUp'><span></span></div><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">##########################################################################</span>
<span class="c1"># NSAp - Copyright (C) CEA, 2021</span>
<span class="c1"># Distributed under the terms of the CeCILL-B license, as published by</span>
<span class="c1"># the CEA-CNRS-INRIA. Refer to the LICENSE file or to</span>
<span class="c1"># http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.html</span>
<span class="c1"># for details.</span>
<span class="c1">##########################################################################</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Spherical sampling &amp; associated utilities.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># Imports</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tempfile</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">collections</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">networkx</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nx</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">transform</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.neighbors</span><span class="w"> </span><span class="kn">import</span> <span class="n">BallTree</span><span class="p">,</span> <span class="n">NearestNeighbors</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.io</span><span class="w"> </span><span class="kn">import</span> <span class="n">HidePrints</span>


<div class="viewcode-block" id="normalize">
<a class="viewcode-back" href="../../../generated/surfify.utils.sampling.normalize.html#surfify.utils.normalize">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">normalize</span><span class="p">(</span><span class="n">vertex</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Return vertex coordinates fixed to the unit sphere.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">vertex</span>
    <span class="n">length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">z</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">idx</span> <span class="o">/</span> <span class="n">length</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)]</span></div>



<span class="n">R</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
<span class="n">STANDARD_ICO</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;vertices&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="n">normalize</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span>
        <span class="n">normalize</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span>
        <span class="n">normalize</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">R</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span>
        <span class="n">normalize</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">R</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span>
        <span class="n">normalize</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">R</span><span class="p">]),</span>
        <span class="n">normalize</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">R</span><span class="p">]),</span>
        <span class="n">normalize</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">R</span><span class="p">]),</span>
        <span class="n">normalize</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">R</span><span class="p">]),</span>
        <span class="n">normalize</span><span class="p">([</span><span class="n">R</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
        <span class="n">normalize</span><span class="p">([</span><span class="n">R</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
        <span class="n">normalize</span><span class="p">([</span><span class="o">-</span><span class="n">R</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
        <span class="n">normalize</span><span class="p">([</span><span class="o">-</span><span class="n">R</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])],</span>
    <span class="s2">&quot;triangles&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">11</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="p">}</span>


<div class="viewcode-block" id="neighbors">
<a class="viewcode-back" href="../../../generated/surfify.utils.sampling.neighbors.html#surfify.utils.neighbors">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">neighbors</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">triangles</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">direct_neighbor</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Build mesh vertices neighbors.</span>

<span class="sd">    This is the base function to build Direct Neighbors (DiNe) kernels.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    neighbors_rec</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from surfify.utils import icosahedron, neighbors</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; from surfify.plotting import plot_trisurf</span>
<span class="sd">    &gt;&gt;&gt; ico2_verts, ico2_tris = icosahedron(order=2)</span>
<span class="sd">    &gt;&gt;&gt; neighs = neighbors(ico2_verts, ico2_tris, direct_neighbor=True)</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots(1, 1, subplot_kw={</span>
<span class="sd">            &quot;projection&quot;: &quot;3d&quot;, &quot;aspect&quot;: &quot;auto&quot;}, figsize=(10, 10))</span>
<span class="sd">    &gt;&gt;&gt; plot_trisurf(ico2_verts, triangles=ico2_tris, colorbar=False, fig=fig,</span>
<span class="sd">                     ax=ax)</span>
<span class="sd">    &gt;&gt;&gt; center = ico2_verts[0]</span>
<span class="sd">    &gt;&gt;&gt; for cnt, idx in enumerate(neighs[0]):</span>
<span class="sd">    &gt;&gt;&gt;     point = ico2_verts[idx]</span>
<span class="sd">    &gt;&gt;&gt;     ax.scatter(point[0], point[1], point[2], marker=&quot;o&quot;, c=&quot;red&quot;,</span>
<span class="sd">                       s=100)</span>
<span class="sd">    &gt;&gt;&gt; ax.scatter(center[0], center[1], center[2], marker=&quot;o&quot;, c=&quot;blue&quot;,</span>
<span class="sd">                   s=100)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vertices: array (N, 3)</span>
<span class="sd">        the icosahedron vertices.</span>
<span class="sd">    triangles: array (M, 3)</span>
<span class="sd">        the icosahedron triangles.</span>
<span class="sd">    depth: int, default 1</span>
<span class="sd">        depth to stop the neighbors search, only paths of length &lt;= depth are</span>
<span class="sd">        returned.</span>
<span class="sd">    direct_neighbor: bool, default False</span>
<span class="sd">        each spherical surface is composed of two types of vertices: 1) 12</span>
<span class="sd">        vertices with each having only 5 direct neighbors; and 2) the</span>
<span class="sd">        remaining vertices with each having 6 direct neighbors. For those</span>
<span class="sd">        vertices with 6 neighbors, DiNe assigns the index 1 to the center</span>
<span class="sd">        vertex and the indices 2-7 to its neighbors sequentially according</span>
<span class="sd">        to the angle between the vector of center vertex to neighboring vertex</span>
<span class="sd">        and the x-axis in the tangent plane. For the 12 vertices with only</span>
<span class="sd">        5 neighbors, DiNe assigns the indices both 1 and 2 to the center</span>
<span class="sd">        vertex, and indices 3-7 to the neighbors in the same way as those</span>
<span class="sd">        vertices with 6 neighbors.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    neighs: dict</span>
<span class="sd">        a dictionary with vertices row index as keys and a dictionary of</span>
<span class="sd">        neighbors vertices row indexes organized by rings as values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">vertex_adjacency_graph</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">triangles</span><span class="p">)</span>
    <span class="n">degrees</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">node</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">degree</span><span class="p">())</span>
    <span class="n">neighs</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">):</span>
        <span class="n">node_neighs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># node_neighs = [idx for idx in graph.neighbors(node)]</span>
        <span class="k">for</span> <span class="n">neigh</span><span class="p">,</span> <span class="n">ring</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">single_source_shortest_path_length</span><span class="p">(</span>
                <span class="n">graph</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="n">depth</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">ring</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">node_neighs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">ring</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neigh</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">direct_neighbor</span><span class="p">:</span>
            <span class="n">_node_neighs</span><span class="p">,</span> <span class="n">_missing_neighs</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">{}</span>
            <span class="n">n_neighs</span><span class="p">,</span> <span class="n">center_missing_neighs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">ring</span><span class="p">,</span> <span class="n">ring_neighs</span> <span class="ow">in</span> <span class="n">node_neighs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span>
                    <span class="n">get_angle_with_xaxis</span><span class="p">(</span><span class="n">vertices</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="n">vertices</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="n">vec</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">vec</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">[</span><span class="n">ring_neighs</span><span class="p">]])</span>
                <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
                <span class="n">ring_neighs</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span>
                    <span class="nb">zip</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">ring_neighs</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">pair</span><span class="p">:</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
                <span class="n">node_neighs</span><span class="p">[</span><span class="n">ring</span><span class="p">]</span> <span class="o">=</span> <span class="n">ring_neighs</span>
                <span class="n">n_neighs</span> <span class="o">+=</span> <span class="mi">6</span> <span class="o">*</span> <span class="n">ring</span>
                <span class="n">_center_neighs</span> <span class="o">=</span> <span class="n">node_neighs</span><span class="p">[</span><span class="n">ring</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">ring</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">[</span><span class="n">node</span><span class="p">]</span>
                <span class="n">_node_missing_neighs</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">_node</span> <span class="k">for</span> <span class="n">_node</span> <span class="ow">in</span> <span class="n">_center_neighs</span> <span class="k">if</span> <span class="n">degrees</span><span class="p">[</span><span class="n">_node</span><span class="p">]</span> <span class="o">==</span> <span class="mi">5</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">_node</span><span class="p">,</span> <span class="n">_counts</span> <span class="ow">in</span> <span class="n">_missing_neighs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">ring_neighs</span> <span class="o">=</span> <span class="p">[</span><span class="n">_node</span><span class="p">]</span> <span class="o">*</span> <span class="n">_counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ring_neighs</span>
                    <span class="n">_missing_neighs</span><span class="p">[</span><span class="n">_node</span><span class="p">]</span> <span class="o">=</span> <span class="n">_counts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="k">for</span> <span class="n">_node</span> <span class="ow">in</span> <span class="n">_node_missing_neighs</span><span class="p">:</span>
                    <span class="n">_missing_neighs</span><span class="p">[</span><span class="n">_node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">ring</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">_node</span> <span class="o">==</span> <span class="n">node</span><span class="p">:</span>
                        <span class="n">center_missing_neighs</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">continue</span>
                    <span class="n">_node_neighs</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">_node_neighs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">_node</span><span class="p">),</span> <span class="n">_node</span><span class="p">)</span>
                <span class="n">_node_neighs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ring_neighs</span><span class="p">)</span>
            <span class="n">_node_neighs</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">center_missing_neighs</span><span class="p">:</span>
                <span class="n">_node_neighs</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_node_neighs</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n_neighs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Mesh is not an icosahedron.&quot;</span><span class="p">)</span>
            <span class="n">node_neighs</span> <span class="o">=</span> <span class="n">_node_neighs</span>
        <span class="n">neighs</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_neighs</span>
    <span class="k">return</span> <span class="n">neighs</span></div>



<div class="viewcode-block" id="vertex_adjacency_graph">
<a class="viewcode-back" href="../../../generated/surfify.utils.sampling.vertex_adjacency_graph.html#surfify.utils.vertex_adjacency_graph">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">vertex_adjacency_graph</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">triangles</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Build a networkx graph representation of the vertices and</span>
<span class="sd">    their connections in the mesh.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    This is useful for getting nearby vertices for a given vertex,</span>
<span class="sd">    potentially for some simple smoothing techniques.</span>
<span class="sd">    &gt;&gt;&gt; graph = mesh.vertex_adjacency_graph</span>
<span class="sd">    &gt;&gt;&gt; graph.neighbors(0)</span>
<span class="sd">    &gt; [1, 3, 4]</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vertices: array (N, 3)</span>
<span class="sd">        the icosahedron vertices.</span>
<span class="sd">    triangles: array (M, 3)</span>
<span class="sd">        the icosahedron triangles.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    graph: networkx.Graph</span>
<span class="sd">        Graph representing vertices and edges between</span>
<span class="sd">        them where vertices are nodes and edges are edges</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)))</span>
    <span class="n">edges</span><span class="p">,</span> <span class="n">edges_triangle</span> <span class="o">=</span> <span class="n">triangles_to_edges</span><span class="p">(</span><span class="n">triangles</span><span class="p">)</span>
    <span class="n">edges_cache</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="n">smaller_index</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">)</span>
        <span class="n">greater_index</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">)</span>
        <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">-</span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">smaller_index</span><span class="p">,</span> <span class="n">greater_index</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">edges_cache</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">edges_cache</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">smaller_index</span><span class="p">,</span> <span class="n">greater_index</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">graph</span></div>



<div class="viewcode-block" id="get_angle_with_xaxis">
<a class="viewcode-back" href="../../../generated/surfify.utils.sampling.get_angle_with_xaxis.html#surfify.utils.get_angle_with_xaxis">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_angle_with_xaxis</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">normal</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Project a point to the sphere tangent plane and compute the angle</span>
<span class="sd">    with the x-axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    center: array (3, )</span>
<span class="sd">        a point in the plane.</span>
<span class="sd">    normal: array (3, )</span>
<span class="sd">        the normal to the plane.</span>
<span class="sd">    points: array (3, )</span>
<span class="sd">        the points to be projected.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Assert is array</span>
    <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>
    <span class="n">normal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>
    <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>

    <span class="c1"># Project points to plane</span>
    <span class="n">vector</span> <span class="o">=</span> <span class="n">point</span> <span class="o">-</span> <span class="n">center</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span>
    <span class="n">projection</span> <span class="o">=</span> <span class="n">point</span> <span class="o">-</span> <span class="n">normal</span> <span class="o">*</span> <span class="n">dist</span>

    <span class="c1"># Compute normal of the new projected x-axis and y-axis</span>
    <span class="k">if</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">center</span><span class="p">)</span>
        <span class="n">ny</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">nx</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">ny</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Compute the angle between projected points and the x-axis</span>
    <span class="n">vector</span> <span class="o">=</span> <span class="n">projection</span> <span class="o">-</span> <span class="n">center</span>
    <span class="n">unit_vector</span> <span class="o">=</span> <span class="n">vector</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">unit_vector</span> <span class="o">=</span> <span class="n">unit_vector</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>
    <span class="n">unit_nx</span> <span class="o">=</span> <span class="n">nx</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span>
    <span class="n">cos_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">unit_vector</span><span class="p">,</span> <span class="n">unit_nx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cos_theta</span> <span class="o">&gt;</span> <span class="mf">1.</span><span class="p">:</span>
        <span class="n">cos_theta</span> <span class="o">=</span> <span class="mf">1.</span>
    <span class="k">elif</span> <span class="n">cos_theta</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">1.</span><span class="p">:</span>
        <span class="n">cos_theta</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">cos_theta</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">unit_vector</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">angle</span>

    <span class="k">return</span> <span class="n">angle</span></div>



<div class="viewcode-block" id="triangles_to_edges">
<a class="viewcode-back" href="../../../generated/surfify.utils.sampling.triangles_to_edges.html#surfify.utils.triangles_to_edges">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">triangles_to_edges</span><span class="p">(</span><span class="n">triangles</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Given a list of triangles, return a list of edges.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    triangles: array int (N, 3)</span>
<span class="sd">        Vertex indices representing triangles.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    edges: array int (N * 3, 2)</span>
<span class="sd">        Vertex indices representing edges.</span>
<span class="sd">    triangles_index: array (N * 3, )</span>
<span class="sd">        Triangle indexes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Each triangles has three edges</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">triangles</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

    <span class="c1"># Edges are in order of triangles due to reshape</span>
    <span class="n">triangles_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">triangles</span><span class="p">)),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">edges</span><span class="p">,</span> <span class="n">triangles_index</span></div>



<div class="viewcode-block" id="neighbors_rec">
<a class="viewcode-back" href="../../../generated/surfify.utils.sampling.neighbors_rec.html#surfify.utils.neighbors_rec">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">neighbors_rec</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">triangles</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">zoom</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Build rectangular grid neighbors and weights.</span>

<span class="sd">    This is the base function to build Rectangular Patch (RePa) kernels.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    neighbors</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from surfify.utils import icosahedron, neighbors_rec</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; from surfify.plotting import plot_trisurf</span>
<span class="sd">    &gt;&gt;&gt; ico2_verts, ico2_tris = icosahedron(order=2)</span>
<span class="sd">    &gt;&gt;&gt; neighs = neighbors_rec(ico2_verts, ico2_tris, size=3, zoom=3)</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots(1, 1, subplot_kw={</span>
<span class="sd">            &quot;projection&quot;: &quot;3d&quot;, &quot;aspect&quot;: &quot;auto&quot;}, figsize=(10, 10))</span>
<span class="sd">    &gt;&gt;&gt; plot_trisurf(ico2_verts, triangles=ico2_tris, colorbar=False, fig=fig,</span>
<span class="sd">                     ax=ax)</span>
<span class="sd">    &gt;&gt;&gt; center = ico2_verts[0]</span>
<span class="sd">    &gt;&gt;&gt; for cnt, point in enumerate(neighs[2][0]):</span>
<span class="sd">    &gt;&gt;&gt;     ax.scatter(point[0], point[1], point[2], marker=&quot;o&quot;, c=&quot;red&quot;,</span>
<span class="sd">                       s=100)</span>
<span class="sd">    &gt;&gt;&gt; ax.scatter(center[0], center[1], center[2], marker=&quot;o&quot;, c=&quot;blue&quot;,</span>
<span class="sd">                   s=100)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vertices: array (N, 3)</span>
<span class="sd">        the icosahedron vertices.</span>
<span class="sd">    triangles: array (N, 3)</span>
<span class="sd">        the icosahedron triangles.</span>
<span class="sd">    size: int, default 5</span>
<span class="sd">        the rectangular grid size.</span>
<span class="sd">    zoom: int, default 5</span>
<span class="sd">        scale factor applied on the unit sphere to control the neighborhood</span>
<span class="sd">        density.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    neighs: array (N, size**2, 3)</span>
<span class="sd">        grid samples neighbors for each vertex.</span>
<span class="sd">    weights: array (N, size**2, 3)</span>
<span class="sd">        grid samples weights with neighbors for each vertex.</span>
<span class="sd">    grid_in_sphere: array (N, size**2, 3)</span>
<span class="sd">        zoomed rectangular grid on the sphere vertices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">grid_in_sphere</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span> <span class="n">size</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">neighs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span> <span class="n">size</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">),</span> <span class="n">size</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">idx1</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vertices</span><span class="p">):</span>
        <span class="n">grid_in_sphere</span><span class="p">[</span><span class="n">idx1</span><span class="p">],</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_rectangular_projection</span><span class="p">(</span>
            <span class="n">node</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">zoom</span><span class="o">=</span><span class="n">zoom</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx2</span><span class="p">,</span> <span class="n">point</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">grid_in_sphere</span><span class="p">[</span><span class="n">idx1</span><span class="p">]):</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vertices</span> <span class="o">-</span> <span class="n">point</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">ordered_neighs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
            <span class="n">neighs</span><span class="p">[</span><span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ordered_neighs</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
            <span class="n">weights</span><span class="p">[</span><span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">neighs</span><span class="p">[</span><span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">]]</span>
            <span class="n">weights</span><span class="p">[</span><span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">]</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">neighs</span><span class="p">[</span><span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">]])</span>
    <span class="k">return</span> <span class="n">neighs</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">grid_in_sphere</span></div>



<div class="viewcode-block" id="get_rectangular_projection">
<a class="viewcode-back" href="../../../generated/surfify.utils.sampling.get_rectangular_projection.html#surfify.utils.get_rectangular_projection">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_rectangular_projection</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">zoom</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Project 2D rectangular grid defined in node tangent space into 3D</span>
<span class="sd">    spherical space.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    node: array (3, )</span>
<span class="sd">        a point in the sphere.</span>
<span class="sd">    size: int, default 5</span>
<span class="sd">        the rectangular grid size.</span>
<span class="sd">    zoom: int, default 5</span>
<span class="sd">        scale factor applied on the unit sphere to control the neighborhood</span>
<span class="sd">        density.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    grid_in_sphere: array (size**2, 3)</span>
<span class="sd">        zoomed rectangular grid on the sphere.</span>
<span class="sd">    grid_in_tplane: array (size**2, 3)</span>
<span class="sd">        zoomed rectangular grid in the tangent space.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check kernel size</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;An odd kernel size is expected.&quot;</span><span class="p">)</span>
    <span class="n">midsize</span> <span class="o">=</span> <span class="n">size</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="c1"># Compute normal of the new projected x-axis and y-axis</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">node</span><span class="p">)</span>
        <span class="n">ny</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">nx</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">ny</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">nx</span> <span class="o">=</span> <span class="n">nx</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span>
    <span class="n">ny</span> <span class="o">=</span> <span class="n">ny</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">ny</span><span class="p">)</span>

    <span class="c1"># Caculate the grid coordinate in tangent plane and project back on sphere</span>
    <span class="n">grid_in_tplane</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">size</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">grid_in_sphere</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">size</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">spacing</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">zoom</span>
    <span class="n">midsize</span> <span class="o">*=</span> <span class="n">spacing</span>
    <span class="n">corner</span> <span class="o">=</span> <span class="n">node</span> <span class="o">-</span> <span class="n">midsize</span> <span class="o">*</span> <span class="n">nx</span> <span class="o">+</span> <span class="n">midsize</span> <span class="o">*</span> <span class="n">ny</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
            <span class="n">point</span> <span class="o">=</span> <span class="n">corner</span> <span class="o">-</span> <span class="n">row</span> <span class="o">*</span> <span class="n">spacing</span> <span class="o">*</span> <span class="n">ny</span> <span class="o">+</span> <span class="n">column</span> <span class="o">*</span> <span class="n">spacing</span> <span class="o">*</span> <span class="n">nx</span>
            <span class="n">grid_in_tplane</span><span class="p">[</span><span class="n">row</span> <span class="o">*</span> <span class="n">size</span> <span class="o">+</span> <span class="n">column</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">point</span>
            <span class="n">grid_in_sphere</span><span class="p">[</span><span class="n">row</span> <span class="o">*</span> <span class="n">size</span> <span class="o">+</span> <span class="n">column</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">point</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">point</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">grid_in_sphere</span><span class="p">,</span> <span class="n">grid_in_tplane</span></div>



<div class="viewcode-block" id="find_neighbors">
<a class="viewcode-back" href="../../../generated/surfify.utils.sampling.find_neighbors.html#surfify.utils.find_neighbors">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">find_neighbors</span><span class="p">(</span><span class="n">start_node</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Recursively find neighbors from a starting node up to a certain order.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    neighbors, neighbors_rec</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from surfify.utils import icosahedron, neighbors_rec, find_neighbors</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; from surfify.plotting import plot_trisurf</span>
<span class="sd">    &gt;&gt;&gt; ico2_verts, ico2_tris = icosahedron(order=2)</span>
<span class="sd">    &gt;&gt;&gt; neighs = neighbors_rec(ico2_verts, ico2_tris, size=3, zoom=3)[0]</span>
<span class="sd">    &gt;&gt;&gt; neighs = neighs.reshape(len(neighs), -1)</span>
<span class="sd">    &gt;&gt;&gt; neighs = neighbors(ico2_verts, ico2_tris, depth=1,</span>
<span class="sd">                           direct_neighbor=True)</span>
<span class="sd">    &gt;&gt;&gt; node = 0</span>
<span class="sd">    &gt;&gt;&gt; node_neighs = find_neighbors(node, order=3, neighbors=neighs)</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots(1, 1, subplot_kw={</span>
<span class="sd">            &quot;projection&quot;: &quot;3d&quot;, &quot;aspect&quot;: &quot;auto&quot;}, figsize=(10, 10))</span>
<span class="sd">    &gt;&gt;&gt; plot_trisurf(ico2_verts, triangles=ico2_tris, colorbar=False, fig=fig,</span>
<span class="sd">                     ax=ax)</span>
<span class="sd">    &gt;&gt;&gt; center = ico2_verts[node]</span>
<span class="sd">    &gt;&gt;&gt; for cnt, idx in enumerate(node_neighs):</span>
<span class="sd">    &gt;&gt;&gt;     point = ico2_verts[idx]</span>
<span class="sd">    &gt;&gt;&gt;     ax.scatter(point[0], point[1], point[2], marker=&quot;o&quot;, c=&quot;red&quot;,</span>
<span class="sd">                       s=100)</span>
<span class="sd">    &gt;&gt;&gt; ax.scatter(center[0], center[1], center[2], marker=&quot;o&quot;, c=&quot;blue&quot;,</span>
<span class="sd">                   s=100)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    start_node: int</span>
<span class="sd">        node index to start search from.</span>
<span class="sd">    order: int</span>
<span class="sd">        order up to which to look for neighbors.</span>
<span class="sd">    neighbors: dict</span>
<span class="sd">        neighbors for each node as generated by the &#39;neighbors&#39; or</span>
<span class="sd">        &#39;neighbors_rec&#39; functions.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    indices: list of int</span>
<span class="sd">        the n-ring neighbors indices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">order</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">start_node</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">neigh</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">[</span><span class="n">start_node</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neigh</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">+=</span> <span class="n">find_neighbors</span><span class="p">(</span><span class="n">neigh</span><span class="p">,</span> <span class="n">order</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">indices</span><span class="p">))</span></div>



<div class="viewcode-block" id="build_freesurfer_ico">
<a class="viewcode-back" href="../../../generated/surfify.utils.sampling.build_freesurfer_ico.html#surfify.utils.build_freesurfer_ico">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">build_freesurfer_ico</span><span class="p">(</span><span class="n">ico_file</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Build FreeSurfer reference icosahedron by fetching existing data</span>
<span class="sd">    and building lower orders using downsampling.</span>

<span class="sd">    Freesurfer coordinates are between -100 and 100, and are rescaled between</span>
<span class="sd">    -1 and 1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ico_file: str, default None</span>
<span class="sd">        path to the generated FreeSurfer reference icosahedron topologies.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">nilearn.surface</span><span class="w"> </span><span class="kn">import</span> <span class="n">load_surf_mesh</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">nilearn.datasets</span><span class="w"> </span><span class="kn">import</span> <span class="n">fetch_surf_fsaverage</span>

    <span class="k">if</span> <span class="n">ico_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">resource_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)),</span> <span class="s2">&quot;resources&quot;</span><span class="p">)</span>
        <span class="n">ico_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">resource_dir</span><span class="p">,</span> <span class="s2">&quot;freesurfer_icos.npz&quot;</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">order</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">surf_name</span> <span class="o">=</span> <span class="s2">&quot;fsaverage</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">HidePrints</span><span class="p">(</span><span class="n">hide_err</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">with</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">TemporaryDirectory</span><span class="p">()</span> <span class="k">as</span> <span class="n">tmpdir</span><span class="p">:</span>
                <span class="n">fsaverage</span> <span class="o">=</span> <span class="n">fetch_surf_fsaverage</span><span class="p">(</span>
                    <span class="n">mesh</span><span class="o">=</span><span class="n">surf_name</span><span class="p">,</span> <span class="n">data_dir</span><span class="o">=</span><span class="n">tmpdir</span><span class="p">)</span>
                <span class="n">vertices</span><span class="p">,</span> <span class="n">triangles</span> <span class="o">=</span> <span class="n">load_surf_mesh</span><span class="p">(</span><span class="n">fsaverage</span><span class="p">[</span><span class="s2">&quot;sphere_left&quot;</span><span class="p">])</span>
            <span class="n">vertices</span> <span class="o">/=</span> <span class="mf">100.</span>
            <span class="n">data</span><span class="p">[</span><span class="n">surf_name</span> <span class="o">+</span> <span class="s2">&quot;.vertices&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertices</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="n">surf_name</span> <span class="o">+</span> <span class="s2">&quot;.triangles&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">triangles</span>
    <span class="k">for</span> <span class="n">order</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">surf_name</span> <span class="o">=</span> <span class="s2">&quot;fsaverage</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="n">up_vertices</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;fsaverage</span><span class="si">{0}</span><span class="s2">.vertices&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="n">up_triangles</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;fsaverage</span><span class="si">{0}</span><span class="s2">.triangles&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="n">vertices</span><span class="p">,</span> <span class="n">triangles</span> <span class="o">=</span> <span class="n">downsample_ico</span><span class="p">(</span><span class="n">up_vertices</span><span class="p">,</span> <span class="n">up_triangles</span><span class="p">,</span> <span class="n">by</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">data</span><span class="p">[</span><span class="n">surf_name</span> <span class="o">+</span> <span class="s2">&quot;.vertices&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertices</span>
        <span class="n">data</span><span class="p">[</span><span class="n">surf_name</span> <span class="o">+</span> <span class="s2">&quot;.triangles&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">triangles</span>
    <span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="n">ico_file</span><span class="p">,</span> <span class="o">**</span><span class="n">data</span><span class="p">)</span></div>



<div class="viewcode-block" id="build_fslr_ref">
<a class="viewcode-back" href="../../../generated/surfify.utils.sampling.build_fslr_ref.html#surfify.utils.build_fslr_ref">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">build_fslr_ref</span><span class="p">(</span><span class="n">ref_file</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Build FSLR reference by fetching existing data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ref_file: str, default None</span>
<span class="sd">        path to the generated FSLR reference topologies.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">nilearn.surface</span><span class="w"> </span><span class="kn">import</span> <span class="n">load_surf_mesh</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">neuromaps.datasets</span><span class="w"> </span><span class="kn">import</span> <span class="n">fetch_fslr</span>

    <span class="k">if</span> <span class="n">ref_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">resource_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)),</span> <span class="s2">&quot;resources&quot;</span><span class="p">)</span>
        <span class="n">ref_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">resource_dir</span><span class="p">,</span> <span class="s2">&quot;fslr_refs.npz&quot;</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">den</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;4k&quot;</span><span class="p">,</span> <span class="s2">&quot;8k&quot;</span><span class="p">,</span> <span class="s2">&quot;32k&quot;</span><span class="p">,</span> <span class="s2">&quot;164k&quot;</span><span class="p">):</span>
        <span class="n">surf_name</span> <span class="o">=</span> <span class="s2">&quot;fslr</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">den</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">HidePrints</span><span class="p">(</span><span class="n">hide_err</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">with</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">TemporaryDirectory</span><span class="p">()</span> <span class="k">as</span> <span class="n">tmpdir</span><span class="p">:</span>
                <span class="n">fslr</span> <span class="o">=</span> <span class="n">fetch_fslr</span><span class="p">(</span><span class="n">density</span><span class="o">=</span><span class="n">den</span><span class="p">,</span> <span class="n">data_dir</span><span class="o">=</span><span class="n">tmpdir</span><span class="p">)</span>
                <span class="n">vertices</span><span class="p">,</span> <span class="n">triangles</span> <span class="o">=</span> <span class="n">load_surf_mesh</span><span class="p">(</span><span class="n">fslr</span><span class="p">[</span><span class="s2">&quot;sphere&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="n">surf_name</span> <span class="o">+</span> <span class="s2">&quot;.vertices&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertices</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="n">surf_name</span> <span class="o">+</span> <span class="s2">&quot;.triangles&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">triangles</span>
    <span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="n">ref_file</span><span class="p">,</span> <span class="o">**</span><span class="n">data</span><span class="p">)</span></div>



<div class="viewcode-block" id="icosahedron">
<a class="viewcode-back" href="../../../generated/surfify.utils.sampling.icosahedron.html#surfify.utils.icosahedron">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">icosahedron</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">standard_ico</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Define an icosahedron mesh of any order.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from surfify.utils import icosahedron</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; from surfify.plotting import plot_trisurf</span>
<span class="sd">    &gt;&gt;&gt; ico3_verts, ico3_tris = icosahedron(order=3)</span>
<span class="sd">    &gt;&gt;&gt; print(ico3_verts.shape, ico3_tris.shape)</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots(1, 1, subplot_kw={</span>
<span class="sd">            &quot;projection&quot;: &quot;3d&quot;, &quot;aspect&quot;: &quot;auto&quot;}, figsize=(10, 10))</span>
<span class="sd">    &gt;&gt;&gt; plot_trisurf(ico3_verts, triangles=ico3_tris, colorbar=False, fig=fig,</span>
<span class="sd">                     ax=ax)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    order: int, default 3</span>
<span class="sd">        the icosahedron order.</span>
<span class="sd">    standard_ico: bool, default False</span>
<span class="sd">        optionally uses a standard icosahedron tessalation.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    vertices: array (N, 3)</span>
<span class="sd">        the icosahedron vertices.</span>
<span class="sd">    triangles: array (M, 3)</span>
<span class="sd">        the icosahedron triangles.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">standard_ico</span><span class="p">:</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="n">STANDARD_ICO</span><span class="p">[</span><span class="s2">&quot;vertices&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">triangles</span> <span class="o">=</span> <span class="n">STANDARD_ICO</span><span class="p">[</span><span class="s2">&quot;triangles&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">middle_point_cache</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
            <span class="n">subdiv</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">tri</span> <span class="ow">in</span> <span class="n">triangles</span><span class="p">:</span>
                <span class="n">v1</span> <span class="o">=</span> <span class="n">middle_point</span><span class="p">(</span><span class="n">tri</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tri</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">middle_point_cache</span><span class="p">)</span>
                <span class="n">v2</span> <span class="o">=</span> <span class="n">middle_point</span><span class="p">(</span><span class="n">tri</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tri</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">middle_point_cache</span><span class="p">)</span>
                <span class="n">v3</span> <span class="o">=</span> <span class="n">middle_point</span><span class="p">(</span><span class="n">tri</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">tri</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">middle_point_cache</span><span class="p">)</span>
                <span class="n">subdiv</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">tri</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v3</span><span class="p">])</span>
                <span class="n">subdiv</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">tri</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v1</span><span class="p">])</span>
                <span class="n">subdiv</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">tri</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">v3</span><span class="p">,</span> <span class="n">v2</span><span class="p">])</span>
                <span class="n">subdiv</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v3</span><span class="p">])</span>
            <span class="n">triangles</span> <span class="o">=</span> <span class="n">subdiv</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
        <span class="n">triangles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">triangles</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">resource_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)),</span> <span class="s2">&quot;resources&quot;</span><span class="p">)</span>
        <span class="n">resource_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">resource_dir</span><span class="p">,</span> <span class="s2">&quot;freesurfer_icos.npz&quot;</span><span class="p">)</span>
        <span class="n">icos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">resource_file</span><span class="p">)</span>
        <span class="n">surf_name</span> <span class="o">=</span> <span class="s2">&quot;fsaverage</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="n">icos</span><span class="p">[</span><span class="n">surf_name</span> <span class="o">+</span> <span class="s2">&quot;.vertices&quot;</span><span class="p">]</span>
            <span class="n">triangles</span> <span class="o">=</span> <span class="n">icos</span><span class="p">[</span><span class="n">surf_name</span> <span class="o">+</span> <span class="s2">&quot;.triangles&quot;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-- available topologies:&quot;</span><span class="p">,</span> <span class="n">icos</span><span class="o">.</span><span class="n">files</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">err</span>

    <span class="k">return</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">triangles</span></div>



<div class="viewcode-block" id="middle_point">
<a class="viewcode-back" href="../../../generated/surfify.utils.sampling.middle_point.html#surfify.utils.middle_point">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">middle_point</span><span class="p">(</span><span class="n">point_1</span><span class="p">,</span> <span class="n">point_2</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">middle_point_cache</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Find a middle point and project it to the unit sphere.</span>

<span class="sd">    This function is only used to build an icosahedron geometry.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># We check if we have already cut this edge first to avoid duplicated verts</span>
    <span class="n">smaller_index</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">point_1</span><span class="p">,</span> <span class="n">point_2</span><span class="p">)</span>
    <span class="n">greater_index</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">point_1</span><span class="p">,</span> <span class="n">point_2</span><span class="p">)</span>
    <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">-</span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">smaller_index</span><span class="p">,</span> <span class="n">greater_index</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">middle_point_cache</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">middle_point_cache</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">middle_point_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="c1"># If it&#39;s not in cache, then we can cut it</span>
    <span class="n">vert_1</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">point_1</span><span class="p">]</span>
    <span class="n">vert_2</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">point_2</span><span class="p">]</span>
    <span class="n">middle</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">elems</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span> <span class="k">for</span> <span class="n">elems</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">vert_1</span><span class="p">,</span> <span class="n">vert_2</span><span class="p">)]</span>
    <span class="n">vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">normalize</span><span class="p">(</span><span class="n">middle</span><span class="p">))</span>
    <span class="n">index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">middle_point_cache</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">middle_point_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>

    <span class="k">return</span> <span class="n">index</span></div>



<div class="viewcode-block" id="patch_tri">
<a class="viewcode-back" href="../../../generated/surfify.utils.sampling.patch_tri.html#surfify.utils.patch_tri">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">patch_tri</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">standard_ico</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;freesurfer&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
              <span class="n">direct_neighbor</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Build triangular patches that map the icosahedron.</span>

<span class="sd">    This is the base function for Vision Transformers.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from surfify.utils import icosahedron, patch_tri</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; from surfify.plotting import plot_trisurf</span>
<span class="sd">    &gt;&gt;&gt; ico3_verts, ico3_tris = icosahedron(order=3)</span>
<span class="sd">    &gt;&gt;&gt; patches = patch_tri(order=3, size=1, size=1)</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots(1, 1, subplot_kw={</span>
<span class="sd">            &quot;projection&quot;: &quot;3d&quot;, &quot;aspect&quot;: &quot;auto&quot;}, figsize=(10, 10))</span>
<span class="sd">    &gt;&gt;&gt; plot_trisurf(ico2_verts, triangles=ico2_tris, colorbar=False, fig=fig,</span>
<span class="sd">                     ax=ax)</span>
<span class="sd">    &gt;&gt;&gt; for cnt, idx in enumerate(patches[10]):</span>
<span class="sd">    &gt;&gt;&gt;     point = ico3_verts[idx]</span>
<span class="sd">    &gt;&gt;&gt;     ax.scatter(point[0], point[1], point[2], marker=&quot;o&quot;, s=100)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    order: int, default 3</span>
<span class="sd">        the icosahedron order.</span>
<span class="sd">    standard_ico: bool, default False</span>
<span class="sd">        optionally uses a standard icosahedron tessalation. FreeSurfer</span>
<span class="sd">        tesselation is used by default.</span>
<span class="sd">    name: str, default &#39;freesurfer&#39;</span>
<span class="sd">        use pre-difined tesselations: freesurfer or fslr.</span>
<span class="sd">    size: int, default 1</span>
<span class="sd">        the patch size.</span>
<span class="sd">    direct_neighbor: bool, default False</span>
<span class="sd">        order patch vertices.</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    patches: array</span>
<span class="sd">        triangular patches containing icosahedron indices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="p">(</span><span class="n">order</span> <span class="o">-</span> <span class="n">size</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Wrong patch definition!&quot;</span>
    <span class="n">vertices</span><span class="p">,</span> <span class="n">triangles</span> <span class="o">=</span> <span class="n">icosahedron</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">standard_ico</span><span class="p">)</span>
    <span class="n">lower_vertices</span><span class="p">,</span> <span class="n">lower_triangles</span> <span class="o">=</span> <span class="n">icosahedron</span><span class="p">(</span><span class="n">order</span> <span class="o">-</span> <span class="n">size</span><span class="p">,</span> <span class="n">standard_ico</span><span class="p">)</span>
    <span class="n">patches</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">tri</span> <span class="ow">in</span> <span class="n">lower_triangles</span><span class="p">:</span>
        <span class="n">_vertices</span> <span class="o">=</span> <span class="p">[</span><span class="n">lower_vertices</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">tri</span><span class="p">]</span>
        <span class="n">_triangles</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span> <span class="o">-</span> <span class="n">size</span><span class="p">):</span>
            <span class="n">subdiv</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">_tri</span> <span class="ow">in</span> <span class="n">_triangles</span><span class="p">:</span>
                <span class="n">v1</span> <span class="o">=</span> <span class="n">middle_point</span><span class="p">(</span><span class="n">_tri</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_tri</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">_vertices</span><span class="p">)</span>
                <span class="n">v2</span> <span class="o">=</span> <span class="n">middle_point</span><span class="p">(</span><span class="n">_tri</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">_tri</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">_vertices</span><span class="p">)</span>
                <span class="n">v3</span> <span class="o">=</span> <span class="n">middle_point</span><span class="p">(</span><span class="n">_tri</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">_tri</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_vertices</span><span class="p">)</span>
                <span class="n">subdiv</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">_tri</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v3</span><span class="p">])</span>
                <span class="n">subdiv</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">_tri</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v1</span><span class="p">])</span>
                <span class="n">subdiv</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">_tri</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">v3</span><span class="p">,</span> <span class="n">v2</span><span class="p">])</span>
                <span class="n">subdiv</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v3</span><span class="p">])</span>
            <span class="n">_triangles</span> <span class="o">=</span> <span class="n">subdiv</span>
        <span class="n">neigh</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">neigh</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">locs</span> <span class="o">=</span> <span class="n">neigh</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">_vertices</span><span class="p">)</span>
        <span class="n">locs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">locs</span><span class="o">.</span><span class="n">squeeze</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">direct_neighbor</span><span class="p">:</span>
            <span class="n">center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">lower_vertices</span><span class="p">[</span><span class="n">tri</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">center</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>
            <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span>
                <span class="n">get_angle_with_xaxis</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">vec</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">vec</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">[</span><span class="n">locs</span><span class="p">]])</span>
            <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
            <span class="n">locs</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span>
                <span class="nb">zip</span><span class="p">(</span><span class="n">angles</span><span class="p">,</span> <span class="n">locs</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">pair</span><span class="p">:</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
        <span class="n">patches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">locs</span><span class="p">)</span>
    <span class="n">patches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">patches</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">patches</span></div>



<div class="viewcode-block" id="number_of_ico_vertices">
<a class="viewcode-back" href="../../../generated/surfify.utils.sampling.number_of_ico_vertices.html#surfify.utils.number_of_ico_vertices">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">number_of_ico_vertices</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Get the number of vertices of an icosahedron of specific order.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    order_of_ico_from_vertices</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from surfify.utils import number_of_ico_vertices, icosahedron</span>
<span class="sd">    &gt;&gt;&gt; ico3_verts, ico3_tris = icosahedron(order=3)</span>
<span class="sd">    &gt;&gt;&gt; n_verts = number_of_ico_vertices(order=3)</span>
<span class="sd">    &gt;&gt;&gt; print(n_verts, ico3_verts.shape)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    order: int, default 3</span>
<span class="sd">        the icosahedron order.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    n_vertices: int</span>
<span class="sd">        number of vertices of the corresponding icosahedron</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">**</span> <span class="n">order</span> <span class="o">+</span> <span class="mi">2</span></div>



<div class="viewcode-block" id="order_of_ico_from_vertices">
<a class="viewcode-back" href="../../../generated/surfify.utils.sampling.order_of_ico_from_vertices.html#surfify.utils.order_of_ico_from_vertices">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">order_of_ico_from_vertices</span><span class="p">(</span><span class="n">n_vertices</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Get the order of an icosahedron from his number of vertices.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    number_of_ico_vertices</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from surfify.utils import order_of_ico_from_vertices, icosahedron</span>
<span class="sd">    &gt;&gt;&gt; ico3_verts, ico3_tris = icosahedron(order=3)</span>
<span class="sd">    &gt;&gt;&gt; order = order_of_ico_from_vertices(len(ico3_verts))</span>
<span class="sd">    &gt;&gt;&gt; print(order)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_vertices: int</span>
<span class="sd">        the number of vertices of an icosahedron.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    order: int</span>
<span class="sd">        the order of the icosahedron</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">((</span><span class="n">n_vertices</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">order</span><span class="p">)</span> <span class="o">!=</span> <span class="n">order</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;This number of vertices does not correspond to those of a &quot;</span>
            <span class="s2">&quot;regular icosahedron.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">order</span><span class="p">)</span></div>



<div class="viewcode-block" id="number_of_neighbors">
<a class="viewcode-back" href="../../../generated/surfify.utils.sampling.number_of_neighbors.html#surfify.utils.number_of_neighbors">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">number_of_neighbors</span><span class="p">(</span><span class="n">depth</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Get the number of neighbors up to a certain depth.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    min_order_to_get_n_neighbors</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from surfify.utils import number_of_neighbors</span>
<span class="sd">    &gt;&gt;&gt; for depth in range(4):</span>
<span class="sd">    &gt;&gt;&gt;     n_neighs = number_of_neighbors(depth)</span>
<span class="sd">    &gt;&gt;&gt;     print(n_neighs)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_vertices: int</span>
<span class="sd">        the number of vertices of an icosahedron.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    order: int</span>
<span class="sd">        the order of the icosahedron.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_neighs</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">order</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">n_neighs</span> <span class="o">+=</span> <span class="mi">6</span> <span class="o">*</span> <span class="n">order</span>
    <span class="k">return</span> <span class="n">n_neighs</span></div>



<div class="viewcode-block" id="min_depth_to_get_n_neighbors">
<a class="viewcode-back" href="../../../generated/surfify.utils.sampling.min_depth_to_get_n_neighbors.html#surfify.utils.min_depth_to_get_n_neighbors">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">min_depth_to_get_n_neighbors</span><span class="p">(</span><span class="n">n_neighs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Get the minimal depth of neighborhood to get a desired number of</span>
<span class="sd">    neighbors.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    number_of_neighbors</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from surfify.utils import min_depth_to_get_n_neighbors, icosahedron</span>
<span class="sd">    &gt;&gt;&gt; ico3_verts, ico3_tris = icosahedron(order=3)</span>
<span class="sd">    &gt;&gt;&gt; depth = min_depth_to_get_n_neighbors(len(ico3_verts) / 2)</span>
<span class="sd">    &gt;&gt;&gt; print(depth)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_vertices: int</span>
<span class="sd">        the number of vertices of an icosahedron.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    order: int</span>
<span class="sd">        the order of the icosahedron.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cum_n_neighs</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">depth</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">cum_n_neighs</span> <span class="o">&lt;</span> <span class="n">n_neighs</span><span class="p">):</span>
        <span class="n">cum_n_neighs</span> <span class="o">+=</span> <span class="mi">6</span> <span class="o">*</span> <span class="n">depth</span>
        <span class="n">depth</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">depth</span></div>



<div class="viewcode-block" id="interpolate">
<a class="viewcode-back" href="../../../generated/surfify.utils.sampling.interpolate.html#surfify.utils.interpolate">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">interpolate</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">target_vertices</span><span class="p">,</span> <span class="n">target_triangles</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Interpolate icosahedron missing data by finding nearest neighbors.</span>

<span class="sd">    Interpolation weights are set to 1 for a regular icosahedron geometry.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    interpolate_data, downsample, downsample_data, downsample_ico</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from surfify.utils import icosahedron, interpolate</span>
<span class="sd">    &gt;&gt;&gt; from surfify.datasets import make_classification</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; from surfify.plotting import plot_trisurf</span>
<span class="sd">    &gt;&gt;&gt; ico2_verts, ico2_tris = icosahedron(order=2)</span>
<span class="sd">    &gt;&gt;&gt; ico3_verts, ico3_tris = icosahedron(order=3)</span>
<span class="sd">    &gt;&gt;&gt; X, y = make_classification(ico2_verts, n_samples=1, n_classes=3,</span>
<span class="sd">                                   scale=1, seed=42)</span>
<span class="sd">    &gt;&gt;&gt; up_indices = interpolate(ico2_verts, ico3_verts, ico3_tris)</span>
<span class="sd">    &gt;&gt;&gt; up_indices = np.asarray(list(up_indices.values()))</span>
<span class="sd">    &gt;&gt;&gt; y_up = y[up_indices.reshape(-1)].reshape(up_indices.shape)</span>
<span class="sd">    &gt;&gt;&gt; y_up = np.mean(y_up, axis=-1)</span>
<span class="sd">    &gt;&gt;&gt; plot_trisurf(ico3_verts, triangles=ico3_tris, texture=y_up,</span>
<span class="sd">                     is_label=False)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vertices: array (n_samples, n_dim)</span>
<span class="sd">        points of data set.</span>
<span class="sd">    target_vertices: array (n_query, n_dim)</span>
<span class="sd">        points to find interpolated texture for.</span>
<span class="sd">    target_triangles: array (n_query, 3)</span>
<span class="sd">        the mesh geometry definition.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    interp_indices: array (n_query, n_feats)</span>
<span class="sd">        the interpolation indices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">interp_indices</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">vertex_adjacency_graph</span><span class="p">(</span><span class="n">target_vertices</span><span class="p">,</span> <span class="n">target_triangles</span><span class="p">)</span>
    <span class="n">common_vertices</span> <span class="o">=</span> <span class="n">downsample</span><span class="p">(</span><span class="n">target_vertices</span><span class="p">,</span> <span class="n">vertices</span><span class="p">)</span>
    <span class="c1"># missing_vertices = (set(range(len(target_vertices))) -</span>
    <span class="c1">#                     set(common_vertices))</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">common_vertices</span><span class="p">:</span>
            <span class="n">interp_indices</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">node_neighs</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                           <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">common_vertices</span><span class="p">]</span>
            <span class="n">interp_indices</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_neighs</span>
    <span class="k">return</span> <span class="n">interp_indices</span></div>



<div class="viewcode-block" id="interpolate_data">
<a class="viewcode-back" href="../../../generated/surfify.utils.sampling.interpolate_data.html#surfify.utils.interpolate_data">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">interpolate_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">by</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">up_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Interpolate data/texture on the icosahedron to an upper order.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    interpolate, downsample, downsample_data, downsample_ico</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from surfify.utils import icosahedron, interpolate_data</span>
<span class="sd">    &gt;&gt;&gt; from surfify.datasets import make_classification</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; from surfify.plotting import plot_trisurf</span>
<span class="sd">    &gt;&gt;&gt; ico2_verts, ico2_tris = icosahedron(order=2)</span>
<span class="sd">    &gt;&gt;&gt; ico4_verts, ico4_tris = icosahedron(order=4)</span>
<span class="sd">    &gt;&gt;&gt; X, y = make_classification(ico2_verts, n_samples=1, n_classes=3,</span>
<span class="sd">                                   scale=1, seed=42)</span>
<span class="sd">    &gt;&gt;&gt; y = y.reshape(1, -1, 1)</span>
<span class="sd">    &gt;&gt;&gt; y_up = interpolate_data(y, by=2).squeeze()</span>
<span class="sd">    &gt;&gt;&gt; plot_trisurf(ico4_verts, triangles=ico4_tris, texture=y_up,</span>
<span class="sd">                     is_label=False)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data: array (n_samples, n_vertices, n_features)</span>
<span class="sd">        data to be upsampled.</span>
<span class="sd">    by: int, default 1</span>
<span class="sd">        number of orders to increase the icosahedron by.</span>
<span class="sd">    up_indices: list of array, default None</span>
<span class="sd">        optionally specify the list of consecutive upsampling vertices</span>
<span class="sd">        indices.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    upsampled_data: array (n_samples, new_n_vertices, n_features)</span>
<span class="sd">        upsampled data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Unexpected input data. Must be (n_samples, n_vertices, &quot;</span>
            <span class="s2">&quot;n_features) but got &#39;</span><span class="si">{0}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">up_indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">order_of_ico_from_vertices</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">ico_verts</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">icosahedron</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="n">up_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">up_order</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">order</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">by</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">up_ico_verts</span><span class="p">,</span> <span class="n">up_ico_tris</span> <span class="o">=</span> <span class="n">icosahedron</span><span class="p">(</span><span class="n">up_order</span><span class="p">)</span>
            <span class="n">_up_indices</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">ico_verts</span><span class="p">,</span> <span class="n">up_ico_verts</span><span class="p">,</span> <span class="n">up_ico_tris</span><span class="p">)</span>
            <span class="n">up_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">_up_indices</span><span class="o">.</span><span class="n">values</span><span class="p">())))</span>
            <span class="n">ico_verts</span> <span class="o">=</span> <span class="n">up_ico_verts</span>
    <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">n_features</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">up_indices</span><span class="p">:</span>
        <span class="n">n_new_vertices</span><span class="p">,</span> <span class="n">n_neighs</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="n">indices</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">n_samples</span><span class="p">,</span> <span class="n">n_new_vertices</span><span class="p">,</span> <span class="n">n_neighs</span><span class="p">,</span> <span class="n">n_features</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span></div>



<div class="viewcode-block" id="downsample">
<a class="viewcode-back" href="../../../generated/surfify.utils.sampling.downsample.html#surfify.utils.downsample">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">downsample</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">target_vertices</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Downsample icosahedron vertices by finding nearest neighbors.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    downsample_data, downsample_ico, interpolate, interpolate_data</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from surfify.utils import icosahedron, downsample</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; from surfify.plotting import plot_trisurf</span>
<span class="sd">    &gt;&gt;&gt; ico2_verts, ico2_tris = icosahedron(order=2)</span>
<span class="sd">    &gt;&gt;&gt; ico3_verts, ico3_tris = icosahedron(order=3)</span>
<span class="sd">    &gt;&gt;&gt; down3to2 = downsample(ico3_verts, ico2_verts)</span>
<span class="sd">    &gt;&gt;&gt; ico3_down_vertices = ico3_verts[down3to2]</span>
<span class="sd">    &gt;&gt;&gt; fig, ax = plt.subplots(1, 1, subplot_kw={</span>
<span class="sd">            &quot;projection&quot;: &quot;3d&quot;, &quot;aspect&quot;: &quot;auto&quot;}, figsize=(10, 10))</span>
<span class="sd">    &gt;&gt;&gt; plot_trisurf(ico3_verts, triangles=ico3_tris, colorbar=False, fig=fig,</span>
<span class="sd">                     ax=ax)</span>
<span class="sd">    &gt;&gt;&gt; for cnt, point in enumerate(ico3_down_vertices):</span>
<span class="sd">    &gt;&gt;&gt;     ax.scatter(point[0], point[1], point[2], marker=&quot;o&quot;, c=&quot;red&quot;,</span>
<span class="sd">                       s=100)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vertices: array (n_samples, n_dim)</span>
<span class="sd">        points of data set.</span>
<span class="sd">    target_vertices: array (n_query, n_dim)</span>
<span class="sd">        points to find nearest neighbors for.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nearest_idx: array (n_query, )</span>
<span class="sd">        index of nearest neighbor in target_vertices for every point in</span>
<span class="sd">        vertices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">vertices</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">target_vertices</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="nb">int</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">BallTree</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">leaf_size</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">distances</span><span class="p">,</span> <span class="n">nearest_idx</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span>
        <span class="n">target_vertices</span><span class="p">,</span> <span class="n">return_distance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">n_duplicates</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nearest_idx</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">nearest_idx</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">n_duplicates</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Could not downsample proprely, &#39;</span><span class="si">{0}</span><span class="s2">&#39; duplicates &quot;</span>
                           <span class="s2">&quot;were found. Are you using an icosahedron &quot;</span>
                           <span class="s2">&quot;mesh?&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_duplicates</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">nearest_idx</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span></div>



<div class="viewcode-block" id="downsample_data">
<a class="viewcode-back" href="../../../generated/surfify.utils.sampling.downsample_data.html#surfify.utils.downsample_data">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">downsample_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">by</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">down_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Downsample data/texture on the icosahedron to a lower order.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    downsample, downsample_ico, interpolate, interpolate_data</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from surfify.utils import icosahedron, downsample_data</span>
<span class="sd">    &gt;&gt;&gt; from surfify.datasets import make_classification</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; from surfify.plotting import plot_trisurf</span>
<span class="sd">    &gt;&gt;&gt; ico2_verts, ico2_tris = icosahedron(order=2)</span>
<span class="sd">    &gt;&gt;&gt; ico4_verts, ico4_tris = icosahedron(order=4)</span>
<span class="sd">    &gt;&gt;&gt; X, y = make_classification(ico4_verts, n_samples=1, n_classes=3,</span>
<span class="sd">                                   scale=1, seed=42)</span>
<span class="sd">    &gt;&gt;&gt; y = y.reshape(1, -1, 1)</span>
<span class="sd">    &gt;&gt;&gt; y_down = downsample_data(y, by=2).squeeze()</span>
<span class="sd">    &gt;&gt;&gt; plot_trisurf(ico2_verts, triangles=ico2_tris, texture=y_down,</span>
<span class="sd">                     is_label=True)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data: array (n_samples, n_vertices, n_features)</span>
<span class="sd">        data to be downsampled.</span>
<span class="sd">    by: int, default 1</span>
<span class="sd">        number of orders to reduce the icosahedron by.</span>
<span class="sd">    down_indices: list of array, default None</span>
<span class="sd">        optionally specify the list of consecutive downsampling vertices</span>
<span class="sd">        indices.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    downsampled_data: array (n_samples, new_n_vertices, n_features)</span>
<span class="sd">        downsampled data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Unexpected input data. Must be (n_samples, n_vertices, &quot;</span>
            <span class="s2">&quot;n_features) but got &#39;</span><span class="si">{0}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">down_indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">order_of_ico_from_vertices</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">ico_verts</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">icosahedron</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="n">down_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">low_order</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">order</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">by</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">low_ico_verts</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">icosahedron</span><span class="p">(</span><span class="n">low_order</span><span class="p">)</span>
            <span class="n">down_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">downsample</span><span class="p">(</span><span class="n">ico_verts</span><span class="p">,</span> <span class="n">low_ico_verts</span><span class="p">))</span>
            <span class="n">ico_verts</span> <span class="o">=</span> <span class="n">low_ico_verts</span>
    <span class="k">for</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">down_indices</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="n">indices</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">data</span></div>



<div class="viewcode-block" id="downsample_ico">
<a class="viewcode-back" href="../../../generated/surfify.utils.sampling.downsample_ico.html#surfify.utils.downsample_ico">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">downsample_ico</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">triangles</span><span class="p">,</span> <span class="n">by</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">down_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Downsample an icosahedron full geometry: vertices and triangles.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    downsample, downsample_data, interpolate, interpolate_data</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from surfify.utils import icosahedron, downsample_ico</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; from surfify.plotting import plot_trisurf</span>
<span class="sd">    &gt;&gt;&gt; ico4_verts, ico4_tris = icosahedron(order=4)</span>
<span class="sd">    &gt;&gt;&gt; ico2_down_verts, ico2_down_tris = downsample_ico(</span>
<span class="sd">            ico4_verts, ico4_tris, by=2)</span>
<span class="sd">    &gt;&gt;&gt; plot_trisurf(ico2_down_verts, triangles=ico2_down_tris, colorbar=False)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vertices: array (N, 3)</span>
<span class="sd">        vertices of the icosahedron to reduce.</span>
<span class="sd">    triangles: array (M, 3)</span>
<span class="sd">        triangles of the icosahedron to reduce.</span>
<span class="sd">    by: int, default 1</span>
<span class="sd">        number of orders to reduce the icosahedron by.</span>
<span class="sd">    down_indices: list of array, default None</span>
<span class="sd">        optionally specify the list of consecutive downsampling vertices</span>
<span class="sd">        indices.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    new_vertices: array (N&#39;, 3)</span>
<span class="sd">        vertices of the newly downsampled icosahedorn.</span>
<span class="sd">    new_triangles: array (M&#39;, 3)</span>
<span class="sd">        triangles of the newly downsampled icosahedron.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">idx_order</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">by</span><span class="p">):</span>
        <span class="n">former_order</span> <span class="o">=</span> <span class="n">order_of_ico_from_vertices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">))</span>
        <span class="n">n_new_vertices</span> <span class="o">=</span> <span class="n">number_of_ico_vertices</span><span class="p">(</span><span class="n">former_order</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">down_indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_new_vertices</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">down_indices</span><span class="p">[</span><span class="n">idx_order</span><span class="p">]</span>
        <span class="n">new_vertices</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
        <span class="n">new_triangles</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">former_neighbors</span> <span class="o">=</span> <span class="n">neighbors</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">triangles</span><span class="p">,</span> <span class="n">direct_neighbor</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">former_neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">former_neighbors</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        <span class="k">for</span> <span class="n">idx_down</span><span class="p">,</span> <span class="n">down_node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">idx_neigh</span><span class="p">,</span> <span class="n">neigh_node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                    <span class="n">former_neighbors</span><span class="p">[</span><span class="n">down_node</span><span class="p">]):</span>
                <span class="c1"># for each central node k (that belong to the smaller</span>
                <span class="c1"># icosahedron), we look in its neighborhood. For each oriented</span>
                <span class="c1"># pair of neighbors we search in their respective neighborhood</span>
                <span class="c1"># for a vertice that is in the downsample indices and is not</span>
                <span class="c1"># the base node k. This trio gives us a triangle of the smaller</span>
                <span class="c1"># icosahedron. We consider the triangles as a list of sets</span>
                <span class="c1"># because the order of vertices do not matter for each triangle</span>
                <span class="k">if</span> <span class="n">neigh_node</span> <span class="o">!=</span> <span class="n">down_node</span><span class="p">:</span>
                    <span class="n">next_neigh_node</span> <span class="o">=</span> <span class="n">former_neighbors</span><span class="p">[</span><span class="n">down_node</span><span class="p">][</span>
                        <span class="p">(</span><span class="n">idx_neigh</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">former_neighbors</span><span class="p">[</span><span class="n">down_node</span><span class="p">])]</span>
                    <span class="n">neigh_node_neighs</span> <span class="o">=</span> <span class="n">former_neighbors</span><span class="p">[</span><span class="n">neigh_node</span><span class="p">]</span>
                    <span class="n">next_neigh_node_neighs</span> <span class="o">=</span> <span class="n">former_neighbors</span><span class="p">[</span><span class="n">next_neigh_node</span><span class="p">]</span>
                    <span class="n">candidates</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx_down</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">neighs</span> <span class="ow">in</span> <span class="p">(</span><span class="n">neigh_node_neighs</span><span class="p">,</span> <span class="n">next_neigh_node_neighs</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">neigh_idx</span> <span class="ow">in</span> <span class="n">neighs</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">neigh_idx</span> <span class="ow">in</span> <span class="n">indices</span> <span class="ow">and</span> <span class="n">neigh_idx</span> <span class="o">!=</span> <span class="n">down_node</span><span class="p">:</span>
                                <span class="n">candidates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="n">indices</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">neigh_idx</span><span class="p">))</span>
                                <span class="k">break</span>

                    <span class="k">if</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_triangles</span> <span class="ow">and</span>
                            <span class="nb">len</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">):</span>
                        <span class="n">new_triangles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">candidates</span><span class="p">))</span>
        <span class="n">new_triangles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">tri</span><span class="p">)</span> <span class="k">for</span> <span class="n">tri</span> <span class="ow">in</span> <span class="n">new_triangles</span><span class="p">])</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="n">new_vertices</span>
        <span class="n">triangles</span> <span class="o">=</span> <span class="n">new_triangles</span>
    <span class="k">return</span> <span class="n">new_vertices</span><span class="p">,</span> <span class="n">new_triangles</span></div>



<div class="viewcode-block" id="find_rotation_interpol_coefs">
<a class="viewcode-back" href="../../../generated/surfify.utils.sampling.find_rotation_interpol_coefs.html#surfify.utils.find_rotation_interpol_coefs">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">find_rotation_interpol_coefs</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">triangles</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span>
                                 <span class="n">interpolation</span><span class="o">=</span><span class="s2">&quot;barycentric&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Function to compute interpolation coefficient asssociated to</span>
<span class="sd">    a rotation of the provided icosahedron. Used by the &#39;rotate_data&#39;</span>
<span class="sd">    function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vertices: array (N, 3)</span>
<span class="sd">        vertices of the icosahedron to reduce.</span>
<span class="sd">    triangles: array (N, 3)</span>
<span class="sd">        triangles of the icosahedron to reduce.</span>
<span class="sd">    angles: 3-uplet</span>
<span class="sd">        the rotation angles in degrees for each axis (Euler representation).</span>
<span class="sd">    interpolation: str, default &#39;barycentric&#39;</span>
<span class="sd">        type of interpolation to use: &#39;euclidian&#39; or &#39;barycentric&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict:</span>
<span class="sd">        neighs: array (N, 3)</span>
<span class="sd">            indices of the three closest neighbors on the rotated icosahedron</span>
<span class="sd">            for each vertice</span>
<span class="sd">        weights: array (N, 3)</span>
<span class="sd">            weights associated to each of these neighbors</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">interpolation</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;euclidian&quot;</span><span class="p">,</span> <span class="s2">&quot;barycentric&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The interpolation should be one of &#39;euclidian&#39; &quot;</span>
                         <span class="s2">&quot;or &#39;barycentric&#39;.&quot;</span><span class="p">)</span>

    <span class="n">n_vertices</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
    <span class="n">neighs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_vertices</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_vertices</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="n">rotation</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">Rotation</span><span class="o">.</span><span class="n">from_euler</span><span class="p">(</span><span class="s2">&quot;xyz&quot;</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">rotated_vertices</span> <span class="o">=</span> <span class="n">rotation</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">interpolation</span> <span class="o">==</span> <span class="s2">&quot;euclidian&quot;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">point</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vertices</span><span class="p">):</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">rotated_vertices</span> <span class="o">-</span> <span class="n">point</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">ordered_neighs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
            <span class="n">neighs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">ordered_neighs</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
            <span class="n">weights</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">neighs</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">neighs</span><span class="p">[</span><span class="n">idx</span><span class="p">]])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
        <span class="n">triangles</span> <span class="o">=</span> <span class="n">order_triangles</span><span class="p">(</span><span class="n">rotated_vertices</span><span class="p">,</span> <span class="n">triangles</span><span class="p">)</span>

        <span class="n">candidate_triangles</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_vertices</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">tri</span> <span class="ow">in</span> <span class="n">triangles</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tri</span><span class="p">:</span>
                <span class="n">candidate_triangles</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tri</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">point</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vertices</span><span class="p">):</span>
            <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># in order not to look in all the triangles for the barycentric</span>
            <span class="c1"># coordinates, we only consider the triangles associated with</span>
            <span class="c1"># the closest rotated vertice</span>
            <span class="n">closest_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">point</span> <span class="o">-</span> <span class="n">rotated_vertices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">triangle</span> <span class="ow">in</span> <span class="n">candidate_triangles</span><span class="p">[</span><span class="n">closest_point</span><span class="p">]:</span>
                <span class="n">T</span> <span class="o">=</span> <span class="n">rotated_vertices</span><span class="p">[</span><span class="n">triangle</span><span class="p">]</span>
                <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">point</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">sum</span><span class="p">((</span><span class="n">B</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">eps</span><span class="p">))</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">neighs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">triangle</span>
                    <span class="n">weights</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">B</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;Barycentric coordinate for vertex </span><span class="si">{}</span><span class="s2"> was not found. &quot;</span>
                    <span class="s2">&quot;It may be due to a numerical error. You might want &quot;</span>
                    <span class="s2">&quot;to consider an other type of interpolation.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">idx</span>
                    <span class="p">))</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;neighs&quot;</span><span class="p">:</span> <span class="n">neighs</span><span class="p">,</span> <span class="s2">&quot;weights&quot;</span><span class="p">:</span> <span class="n">weights</span><span class="p">}</span></div>



<div class="viewcode-block" id="rotate_data">
<a class="viewcode-back" href="../../../generated/surfify.utils.sampling.rotate_data.html#surfify.utils.rotate_data">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">rotate_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">triangles</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span>
                <span class="n">interpolation</span><span class="o">=</span><span class="s2">&quot;barycentric&quot;</span><span class="p">,</span> <span class="n">neighs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Rotate data/texture on an icosahedron. the decorator allows</span>
<span class="sd">    the user not to care about the interpolation weights and neighbors,</span>
<span class="sd">    which are automatically computed and stored to be reused the first</span>
<span class="sd">    time the function is called with given arguments.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from surfify.utils import icosahedron, rotate_data</span>
<span class="sd">    &gt;&gt;&gt; from surfify.datasets import make_classification</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; from surfify.plotting import plot_trisurf</span>
<span class="sd">    &gt;&gt;&gt; ico3_verts, ico3_tris = icosahedron(order=3)</span>
<span class="sd">    &gt;&gt;&gt; X, y = make_classification(ico3_verts, n_samples=1, n_classes=3,</span>
<span class="sd">                                   scale=1, seed=42)</span>
<span class="sd">    &gt;&gt;&gt; y_rot = rotate_data(y.reshape(1, -1, 1), ico3_verts, ico3_tris,</span>
<span class="sd">                            (45, 0, 0)).squeeze()</span>
<span class="sd">    &gt;&gt;&gt; plot_trisurf(ico3_verts, triangles=ico3_tris, texture=y,</span>
<span class="sd">                     is_label=False)</span>
<span class="sd">    &gt;&gt;&gt; plot_trisurf(ico3_verts, triangles=ico3_tris, texture=y_rot,</span>
<span class="sd">                     is_label=False)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data: array (n_samples, N, n_features)</span>
<span class="sd">        data to be rotated.</span>
<span class="sd">    vertices: array (N, 3)</span>
<span class="sd">        vertices of the icosahedron.</span>
<span class="sd">    triangles: array (N, 3)</span>
<span class="sd">        triangles of the icosahedron.</span>
<span class="sd">    angles: 3-uplet</span>
<span class="sd">        the rotation angles in degrees for each axis (Euler representation).</span>
<span class="sd">    interpolation: str, default &#39;barycentric&#39;.</span>
<span class="sd">        the type of interpolation to use: &#39;euclidean&#39; or &#39;barycentric&#39;.</span>
<span class="sd">    neighs: array (N, 3) or None, default None</span>
<span class="sd">        neighbors to interpolate from for each vertex. If None, the function</span>
<span class="sd">        computes the neighbors via the provided interpolation method.</span>
<span class="sd">    weights: array (N, 3) or None, default None</span>
<span class="sd">        weights associated to each neighbors for each vertex.  If None, the</span>
<span class="sd">        function computes the weights via the provided interpolation method.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rotated_data: array (n_samples, n_vertices, n_features)</span>
<span class="sd">        rotated data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Unexpected input data. Must be (n_samples, n_vertices, &quot;</span>
            <span class="s2">&quot;n_features) but got &#39;</span><span class="si">{0}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">neighs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">interp_coefs</span> <span class="o">=</span> <span class="n">find_rotation_interpol_coefs</span><span class="p">(</span>
            <span class="n">vertices</span><span class="p">,</span> <span class="n">triangles</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">interpolation</span><span class="p">)</span>
        <span class="n">neighs</span> <span class="o">=</span> <span class="n">interp_coefs</span><span class="p">[</span><span class="s2">&quot;neighs&quot;</span><span class="p">]</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">interp_coefs</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span>
    <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">n_features</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">n_vertices</span><span class="p">,</span> <span class="n">n_neighs</span> <span class="o">=</span> <span class="n">neighs</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">flat_neighs</span> <span class="o">=</span> <span class="n">neighs</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">flat_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">weights</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">n_samples</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">rotated_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="n">flat_neighs</span><span class="p">]</span> <span class="o">*</span> <span class="n">flat_weights</span>
    <span class="n">rotated_data</span> <span class="o">=</span> <span class="n">rotated_data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">n_vertices</span><span class="p">,</span> <span class="n">n_neighs</span><span class="p">,</span>
                                        <span class="n">n_features</span><span class="p">)</span>
    <span class="n">rotated_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rotated_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">rotated_data</span></div>



<div class="viewcode-block" id="order_triangles">
<a class="viewcode-back" href="../../../generated/surfify.utils.sampling.order_triangles.html#surfify.utils.order_triangles">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">order_triangles</span><span class="p">(</span><span class="n">vertices</span><span class="p">,</span> <span class="n">triangles</span><span class="p">,</span> <span class="n">clockwise_from_center</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Order the icosahedron triangles to be in a clockwise order when viewed</span>
<span class="sd">    from the center of the sphere. Used by the &#39;find_rotation_interpol_coefs&#39;</span>
<span class="sd">    for barycentric interpolation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from surfify.utils import icosahedron, order_triangles</span>
<span class="sd">    &gt;&gt;&gt; ico0_verts, ico0_tris = icosahedron(order=0)</span>
<span class="sd">    &gt;&gt;&gt; clockwise_ico0_tris = order_triangles(</span>
<span class="sd">            ico0_verts, ico0_tris, clockwise_from_center=True)</span>
<span class="sd">    &gt;&gt;&gt; counter_clockwise_ico0_tris = order_triangles(</span>
<span class="sd">            ico0_verts, ico0_tris, clockwise_from_center=False)</span>
<span class="sd">    &gt;&gt;&gt; print(clockwise_ico0_tris)</span>
<span class="sd">    &gt;&gt;&gt; print(counter_clockwise_ico0_tris)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vertices: array (N, 3)</span>
<span class="sd">        the icosahedron&#39;s vertices.</span>
<span class="sd">    triangles: array (M, 3)</span>
<span class="sd">        the icosahedron&#39;s triangles.</span>
<span class="sd">    clockwise_from_center: bool, default True</span>
<span class="sd">        optionally use counter clockwise order.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    reordered_triangles: array (M, 3)</span>
<span class="sd">        reordered triangles.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">reordered_triangles</span> <span class="o">=</span> <span class="n">triangles</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">triangle</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">triangles</span><span class="p">):</span>
        <span class="n">loc_x</span><span class="p">,</span> <span class="n">loc_y</span><span class="p">,</span> <span class="n">loc_z</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">triangle</span><span class="p">]</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">((</span><span class="n">loc_y</span> <span class="o">-</span> <span class="n">loc_x</span><span class="p">),</span> <span class="p">(</span><span class="n">loc_z</span> <span class="o">-</span> <span class="n">loc_x</span><span class="p">))</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">loc_x</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">clockwise_from_center</span> <span class="ow">and</span> <span class="n">w</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span>
                <span class="p">(</span><span class="ow">not</span> <span class="n">clockwise_from_center</span> <span class="ow">and</span> <span class="n">w</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)):</span>
            <span class="n">reordered_triangles</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">triangle</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">reordered_triangles</span></div>

</pre></div>
                    </div>
                <div class="spacer"></div>
		        
		        <!-- Footer -->
		        <div class="section-6-container section-container section-container-image-bg" id="section-6">
			        <div class="container">
			            <div class="row">
		                    <div class="col-md-5 offset-md-1 section-6-box wow fadeInDown">
                                <div class="section-6-title">
		                    	    <p>Follow us</p>
                                </div>
		                    	<div class="section-6-social">
			                    	<a href="https://www.facebook.com/pages/NeuroSpin/171075046414933"><i class="fab fa-facebook-f"></i></a>
									<a href="https://www.youtube.com/CEASaclay"><i class="fab fa-youtube"></i></a>
									<a href="https://twitter.com/neurospin_91"><i class="fab fa-twitter"></i></a>
									<a href="https://github.com/AGrigis/pysphinxdoc"><i class="fab fa-github"></i></a>
                                    <p>&copy; 2025, 
surfify developers
 <antoine.grigis@cea.fr></p>
		                    	</div>
		                    </div>
			            </div>
			        </div>
                </div>
	        
	        </div>
	        <!-- End content -->
        
        </div>
        <!-- End wrapper -->

        <!-- Javascript -->
		<script src="../../../_static/js/jquery-3.3.1.min.js"></script>
		<script src="../../../_static/js/jquery-migrate-3.0.0.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
		<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
        <script src="../../../_static/js/jquery.backstretch.min.js"></script>
        <script src="../../../_static/js/wow.min.js"></script>
        <script src="../../../_static/js/jquery.waypoints.min.js"></script>
        <script src="../../../_static/js/jquery.mCustomScrollbar.concat.min.js"></script>
        <script src="../../../_static/js/scripts.js"></script>
        <script src="../../../_static/js/jquery.mosaic.js"></script>
        <script src="../../../_static/js/search.js"></script>
        <script type="text/javascript">
	        $('.top-content').backstretch("../../../_static/img/backgrounds/banner1.png");
            $('.section-6-container').backstretch("../../../_static/img/backgrounds/footer1.png");
        </script>

    </body>

</html>